# vim: ft=sh
# ENVIRONMENT VARIABLES #
#########################

# No brainer, default to Vim
alias vim="nvim"
export EDITOR="vim"
export VIMCONFIG="$HOME/.vim"
export VIMDATA="$HOME/.vim"

# Tmux auto title
export DISABLE_AUTO_TITLE="true"

# GPG Configuration
export GPG_TTY=$(tty)

# Color LS output to differentiate between directories and files
export LS_OPTIONS="--color=auto"
export CLICOLOR="Yes"
export LSCOLOR=""

# Set Path
export PATH=$HOME/.bin:$HOME/.local/bin:$HOME/bin:/usr/local/sbin:/usr/local/bin:/sbin:$PATH

# Add Rust/Cargo to the path
export PATH="$HOME/.cargo/bin:$PATH"
if [[ -s $HOME/.cargo/env ]] ; then
  source $HOME/.cargo/env
fi

# ALIASES #
###########

# Standard Shell
alias c='clear'
alias l='ls -al'
alias bloat='du -k | sort -nr | more'
alias sc='systemctl'
alias jc='journalctl'

# Bundle Exec
alias be="bundle exec"

# Git
alias g='git status -s'
alias ga='git add --all'
alias gb='git branch'
alias gc='git commit -m'
alias gca='git commit -am'
alias gco='git checkout'
alias gcob='git checkout -b'
alias gl='git l'

# tmux
alias switch='tmux switch-session -t'
alias tmk='tmux kill-session -t'
alias tls='tmux ls'
alias load='tmuxp load'

attach() {
  if [ -z "$1" ]
  then
    tmux attach-session -t 0
  else
    tmux attach-session -t "$1"
  fi
}

# Docker
alias de='docker exec'
alias dclean='docker ps -a -q -f status=exited | xargs -t docker rm'
alias diclean='docker images -q -f dangling=true | xargs -t docker rmi'
alias dvclean='docker volume ls -q -f dangling=true | xargs -t docker volume rm'
alias dgc='dclean && diclean && dvclean'
alias dps='docker ps'
alias dstop='docker stop `docker ps -q`'

# Docker Compose
alias dc='docker-compose'
alias dcu='docker-compose up'
alias dcr='docker-compose run --rm'

# Flush DNS Cache
alias dnsflush='dscacheutil -flushcache; sudo killall -HUP mDNSResponder'

# Reload SHELL
alias r='exec $SHELL'

# Ripgrep as Silver Searcher
if ! command -v ag &> /dev/null; then alias ag=rg; fi

# Tmux project orchestration
function rdev() {
  WORKSPACE=$1 tmuxp load ~/.tmuxp/rails_dev.yaml
}

# Dev setup
[ -f /opt/dev/dev.sh ] && source /opt/dev/dev.sh

# Keychain loader if present
type keychain >/dev/null 2>&1 && eval `keychain --agents ssh --eval ~/.ssh/id_ed25519`

# asdf setup
if [ -e $HOME/.asdf/asdf.sh ]; then
  . $HOME/.asdf/asdf.sh
  . $HOME/.asdf/completions/asdf.bash
fi

# Nix setup
if [ -e $HOME/.nix-profile/etc/profile.d/nix.sh ]; then . $HOME/.nix-profile/etc/profile.d/nix.sh; fi # added by Nix installer

# Chruby setup
[[ -f /opt/dev/sh/chruby/chruby.sh ]] && type chruby >/dev/null 2>&1 || chruby () { source /opt/dev/sh/chruby/chruby.sh; chruby "$@"; }

# Direnv setup
type direnv >/dev/null 2>&1 && eval "$(direnv hook bash)"

# Nvm setup
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

# 1Password SSH Management in WSL
if [[ $OSTYPE == 'linux'* ]]; then
  if [ -e $HOME/.agent-bridge.sh ]; then
    source $HOME/.agent-bridge.sh
  fi
fi

# spin shell_gpt setup
[[ -f $HOME/.secrets ]] && . $HOME/.secrets
[[ -f /etc/spin/secrets/openai-base-url ]] && export API_BASE_URL=$(cat /etc/spin/secrets/openai-base-url)
[[ -f /etc/spin/secrets/openai-api-key ]] && export OPENAI_API_KEY=$(cat /etc/spin/secrets/openai-api-key)

# Fly.io setup
export FLYCTL_INSTALL="$HOME/.fly"
export PATH="$FLYCTL_INSTALL/bin:$PATH"
